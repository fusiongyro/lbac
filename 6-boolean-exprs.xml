<?xml version="1.0" encoding="utf-8"?>
<chapter xmlns:id="part-ii-expression-parsing"
	 xmlns="http://docbook.org/ns/docbook" version="5.0">
  <title>Boolean Expressions</title>
  <info><date>31 August 1988</date></info>
  <sect1 xml:id="introduction">
    <title>Introduction</title>
    <para>
      In Part V of this series, we took a look at control constructs,
      and developed parsing routines to translate them into object code.
      We ended up with a nice, relatively rich set of constructs.
    </para>
    <para>
      As we left the parser, though, there was one big hole in our
      capabilities: we did not address the issue of the branch
      condition. To fill the void, I introduced to you a dummy parse
      routine called Condition, which only served as a place-keeper for
      the real thing.
    </para>
    <para>
      One of the things we'll do in this session is to plug that hole by
      expanding Condition into a true parser/translator.
    </para>
  </sect1>
  <sect1 xmlns:id="the-plan">
    <title>The Plan</title>
    <para>
      We're going to approach this installment a bit differently than
      any of the others. In those other installments, we started out
      immediately with experiments using the Pascal compiler, building
      up the parsers from very rudimentary beginnings to their final
      forms, without spending much time in planning beforehand. That's
      called coding without specs, and it's usually frowned upon. We
      could get away with it before because the rules of arithmetic are
      pretty well established... we know what a '+' sign is supposed to
      mean without having to discuss it at length. The same is true for
      branches and loops. But the ways in which programming languages
      implement logic vary quite a bit from language to language. So
      before we begin serious coding, we'd better first make up our
      minds what it is we want. And the way to do that is at the level
      of the BNF syntax rules (the <emphasis>grammar</emphasis>).
    </para>
  </sect1>
  <sect1 xmlns:id="the-grammar">
    <title>The Grammar</title>
    <para>
      For some time now, we've been implementing BNF syntax equations
      for arithmetic expressions, without ever actually writing them
      down all in one place. It's time that we did so. They are:
    </para>
    <productionset>
      <production xml:id="expr">
	<lhs>&lt;expression&gt;</lhs>
	<rhs>
	  <nonterminal def="#unary-op">&lt;unary op&gt;</nonterminal>
	  <nonterminal def="#term">&lt;term&gt;</nonterminal>
	  [<nonterminal def="#add-op">&lt;addop&gt;</nonterminal>
	   <nonterminal def="#term">&lt;term&gt;</nonterminal>]*
	</rhs>
      </production>
      <production xml:id="term">
	<lhs>&lt;term&gt;</lhs>
	<rhs>
	  <nonterminal def="#factor">&lt;factor&gt;</nonterminal>
	  [<nonterminal def="#mul-op">&lt;mulop&gt;</nonterminal>
	   <nonterminal def="#factor">&lt;factor&gt;</nonterminal>]*
	</rhs>
      </production>
      <production xml:id="factor">
	<lhs>&lt;factor&gt;</lhs>
	<rhs>
	  <nonterminal def="#integer">&lt;integer&gt;</nonterminal>
	  | <nonterminal def="#varible">&lt;variable&gt;</nonterminal>
	  | ( <nonterminal def="#expr">&lt;expression&gt;</nonterminal> )
	</rhs>
      </production>
    </productionset>
    <para>
      (Remember, the nice thing about this grammar is that it enforces
      the operator precedence hierarchy that we normally expect for
      algebra.)
    </para>
    <para>
      Actually, while we're on the subject, I'd like to amend this
      grammar a bit right now. The way we've handled the unary minus is
      a bit awkward. I've found that it's better to write the grammar
      this way:
    </para>
    <programlisting>
&lt;expression&gt;    ::= &lt;term&gt; [&lt;addop&gt; &lt;term&gt;]*
&lt;term&gt;          ::= &lt;signed factor&gt; [&lt;mulop&gt; factor]*
&lt;signed factor&gt; ::= [&lt;addop&gt;] &lt;factor&gt;
&lt;factor&gt;        ::= &lt;integer&gt; | &lt;variable&gt; | (&lt;expression&gt;)
</programlisting>
    <para>
      This puts the job of handling the unary minus onto Factor, which
      is where it really belongs.
    </para>
    <para>
      This doesn't mean that you have to go back and recode the programs
      you've already written, although you're free to do so if you like.
      But I will be using the new syntax from now on.
    </para>
    <para>
      Now, it probably won't come as a shock to you to learn that we can
      define an analogous grammar for Boolean algebra. A typical set or
      rules is:
    </para>
    <programlisting>
&lt;b-expression&gt;::= &lt;b-term&gt; [&lt;orop&gt; &lt;b-term&gt;]*
&lt;b-term&gt;      ::= &lt;not-factor&gt; [AND &lt;not-factor&gt;]*
&lt;not-factor&gt;  ::= [NOT] &lt;b-factor&gt;
&lt;b-factor&gt;    ::= &lt;b-literal&gt; | &lt;b-variable&gt; | (&lt;b-expression&gt;)
</programlisting>
    <para>
      Notice that in this grammar, the operator <literal>AND</literal>
      is analogous to <literal>'*'</literal>, and <literal>OR</literal>
      (and exclusive <literal>OR</literal>) to <literal>'+'</literal>.
      The <literal>NOT</literal> operator is analogous to a unary minus.
      This hierarchy is not absolutely standard… some languages, notably
      Ada, treat all logical operators as having the same precedence
      level… but it seems natural.
    </para>
    <para>
      Notice also the slight difference between the way the
      <literal>NOT</literal> and the unary minus are handled. In
      algebra, the unary minus is considered to go with the whole term,
      and so never appears but once in a given term. So an expression
      like
    </para>
    <programlisting>
                a * -b
</programlisting>
    <para>
      or worse yet,
    </para>
    <programlisting>
                a - -b
</programlisting>
    <para>
      is not allowed. In Boolean algebra, though, the expression
    </para>
    <programlisting>
                a AND NOT b
</programlisting>
    <para>
      makes perfect sense, and the syntax shown allows for that.
    </para>
  </sect1>
  <sect1 xmlns:id="relops">
    <title>Relops</title>
    <para>
      OK, assuming that you're willing to accept the grammar I've shown
      here, we now have syntax rules for both arithmetic and Boolean
      algebra. The sticky part comes in when we have to combine the two.
      Why do we have to do that? Well, the whole subject came up because
      of the need to process the &quot;predicates&quot; (conditions)
      associated with control statements such as the
      <literal>IF</literal>. The predicate is required to have a Boolean
      value; that is, it must evaluate to either <literal>TRUE</literal>
      or <literal>FALSE</literal>. The branch is then taken or not
      taken, depending on that value. What we expect to see going on in
      procedure Condition, then, is the evaluation of a Boolean
      expression.
    </para>
    <para>
      But there's more to it than that. A pure Boolean expression can
      indeed be the predicate of a control statement… things like
    </para>
    <programlisting>
      IF a AND NOT b THEN...
</programlisting>
    <para>
      But more often, we see Boolean algebra show up in such things as
    </para>
    <programlisting>
      IF (x &gt;= 0) and (x &lt;= 100) THEN...
</programlisting>
    <para>
      Here, the two terms in parens are Boolean expressions, but the
      individual terms being compared: x, 0, and 100, are
      <emphasis>numeric</emphasis> in nature. The <emphasis>relational
      operators</emphasis> &gt;= and &lt;= are the catalysts by which
      the Boolean and the arithmetic ingredients get merged together.
    </para>
    <para>
      Now, in the example above, the terms being compared are just that:
      terms. However, in general each side can be a math expression. So
      we can define a <emphasis>relation</emphasis> to be:
    </para>
    <programlisting>
 &lt;relation&gt; ::= &lt;expression&gt; &lt;relop&gt; &lt;expression&gt;  ,
</programlisting>
    <para>
      where the expressions we're talking about here are the old numeric
      type, and the relops are any of the usual symbols
    </para>
    <programlisting>
           =, &lt;&gt; (or !=), &lt;, &gt;, &lt;=, and &gt;=
</programlisting>
    <para>
      If you think about it a bit, you'll agree that, since this kind of
      predicate has a single Boolean value, <literal>TRUE</literal> or
      <literal>FALSE</literal>, as its result, it is really just another
      kind of factor. So we can expand the definition of a Boolean
      factor above to read:
    </para>
    <programlisting>
&lt;b-factor&gt; ::=    &lt;b-literal&gt;
                | &lt;b-variable&gt;
                | (&lt;b-expression&gt;)
                | &lt;relation&gt;
</programlisting>
    <para>
      <emphasis>That's</emphasis> the connection! The relops and the
      relation they define serve to wed the two kinds of algebra. It is
      worth noting that this implies a hierarchy where the arithmetic
      expression has a <emphasis>higher</emphasis> precedence that a
      Boolean factor, and therefore than all the Boolean operators. If
      you write out the precedence levels for all the operators, you
      arrive at the following list:
    </para>
    <programlisting>
      Level   Syntax Element     Operator

      0       factor             literal, variable
      1       signed factor      unary minus
      2       term               *, /
      3       expression         +, -
      4       b-factor           literal, variable, relop
      5       not-factor         NOT
      6       b-term             AND
      7       b-expression       OR, XOR
</programlisting>
    <para>
      If we're willing to accept that many precedence levels, this
      grammar seems reasonable. Unfortunately, it won't work! The
      grammar may be great in theory, but it's no good at all in the
      practice of a top-down parser. To see the problem, consider the
      code fragment:
    </para>
    <programlisting>
 IF ((((((A + B + C) &lt; 0 ) AND….
</programlisting>
    <para>
      When the parser is parsing this code, it knows after it sees the
      IF token that a Boolean expression is supposed to be next. So it
      can set up to begin evaluating such an expression. But the first
      expression in the example is an ARITHMETIC expression, A + B + C.
      What's worse, at the point that the parser has read this much of
      the input line:
    </para>
    <programlisting>
 IF ((((((A   ,
</programlisting>
    <para>
      it still has no way of knowing which kind of expression it's
      dealing with. That won't do, because we must have different
      recognizers for the two cases. The situation can be handled
      without changing any of our definitions, but only if we're willing
      to accept an arbitrary amount of backtracking to work our way out
      of bad guesses. No compiler writer in his right mind would agree
      to that.
    </para>
    <para>
      What's going on here is that the beauty and elegance of BNF
      grammar has met face to face with the realities of compiler
      technology.
    </para>
    <para>
      To deal with this situation, compiler writers have had to make
      compromises so that a single parser can handle the grammar without
      backtracking.
    </para>
  </sect1>
  <sect1 xmlns:id="fixing-the-grammar">
    <title>Fixing the Grammar</title>
    <para>
      The problem that we've encountered comes up because our
      definitions of both arithmetic and Boolean factors permit the use
      of parenthesized expressions. Since the definitions are recursive,
      we can end up with any number of levels of parentheses, and the
      parser can't know which kind of expression it's dealing with.
    </para>
    <para>
      The solution is simple, although it ends up causing profound
      changes to our grammar. We can only allow parentheses in one kind
      of factor. The way to do that varies considerably from language to
      language. This is one place where there is <emphasis>no</emphasis>
      agreement or convention to help us.
    </para>
    <para>
      When Niklaus Wirth designed Pascal, the desire was to limit the
      number of levels of precedence (fewer parse routines, after all).
      So the <literal>OR</literal> and exclusive <literal>OR</literal>
      operators are treated just like an <literal>Addop</literal> and
      processed at the level of a math expression. Similarly, the
      <literal>AND</literal> is treated like a <literal>Mulop</literal>
      and processed with <literal>Term</literal>. The precedence levels
      are
    </para>
    <programlisting>
      Level   Syntax Element     Operator

      0       factor             literal, variable
      1       signed factor      unary minus, NOT
      2       term               *, /, AND
      3       expression         +, -, OR
</programlisting>
    <para>
      Notice that there is only <emphasis>one</emphasis> set of syntax
      rules, applying to both kinds of operators. According to this
      grammar, then, expressions like
    </para>
    <programlisting>
 x + (y AND NOT z) DIV 3
</programlisting>
    <para>
      are perfectly legal. And, in fact, they <emphasis>are</emphasis>…
      as far as the parser is concerned. Pascal doesn't allow the mixing
      of arithmetic and Boolean variables, and things like this are
      caught at the <emphasis>semantic</emphasis> level, when it comes
      time to generate code for them, rather than at the syntax level.
    </para>
    <para>
      The authors of C took a diametrically opposite approach: they
      treat the operators as different, and have something much more
      akin to our seven levels of precedence. In fact, in C there are no
      fewer than 17 levels! That's because C also has the operators
      <literal>'='</literal>, <literal>'+='</literal> and its kin,
      <literal>'&lt;&lt;'</literal>, <literal>'&gt;&gt;'</literal>,
      <literal>'++'</literal>, <literal>'--'</literal>, etc. Ironically,
      although in C the arithmetic and Boolean operators are treated
      separately, the variables are <emphasis>not</emphasis> … there are
      no Boolean or logical variables in C, so a Boolean test can be
      made on any integer value.
    </para>
    <para>
      We'll do something that's sort of in-between. I'm tempted to stick
      mostly with the Pascal approach, since that seems the simplest
      from an implementation point of view, but it results in some
      funnies that I never liked very much, such as the fact that, in
      the expression
    </para>
    <programlisting>
 IF (c &gt;= 'A') and (c &lt;= 'Z') then…
</programlisting>
    <para>
      the parens above are <emphasis>required</emphasis>. I never
      understood why before, and neither my compiler nor any human ever
      explained it very well, either. But now, we can all see that the
      <literal>'and'</literal> operator, having the precedence of a
      multiply, has a higher one than the relational operators, so
      without the parens the expression is equivalent to
    </para>
    <programlisting>
 IF c &gt;= ('A' and c) &lt;= 'Z' then
</programlisting>
    <para>
      which doesn't make sense.
    </para>
    <para>
      In any case, I've elected to separate the operators into different
      levels, although not as many as in C.
    </para>
    <programlisting>
 &lt;b-expression&gt; ::= &lt;b-term&gt; [&lt;orop&gt; &lt;b-term&gt;]*
 &lt;b-term&gt;       ::= &lt;not-factor&gt; [AND &lt;not-factor&gt;]*
 &lt;not-factor&gt;   ::= [NOT] &lt;b-factor&gt;
 &lt;b-factor&gt;     ::= &lt;b-literal&gt; | &lt;b-variable&gt; | &lt;relation&gt;
 &lt;relation&gt;     ::= | &lt;expression&gt; [&lt;relop&gt; &lt;expression]
 &lt;expression&gt;   ::= &lt;term&gt; [&lt;addop&gt; &lt;term&gt;]*
 &lt;term&gt;         ::= &lt;signed factor&gt; [&lt;mulop&gt; factor]*
 &lt;signed factor&gt;::= [&lt;addop&gt;] &lt;factor&gt;
 &lt;factor&gt;       ::= &lt;integer&gt; | &lt;variable&gt; | (&lt;b-expression&gt;)
</programlisting>
    <para>
      This grammar results in the same set of seven levels that I showed
      earlier. Really, it's almost the same grammar… I just removed the
      option of parenthesized b-expressions as a possible b-factor, and
      added the relation as a legal form of b-factor.
    </para>
    <para>
      There is one subtle but crucial difference, which is what makes
      the whole thing work. Notice the square brackets in the definition
      of a relation. This means that the relop and the second expression
      are <emphasis>optional</emphasis>.
    </para>
    <para>
      A strange consequence of this grammar (and one shared by C) is
      that <emphasis>every</emphasis> expression is potentially a
      Boolean expression. The parser will always be looking for a
      Boolean expression, but will &quot;settle&quot; for an arithmetic
      one. To be honest, that's going to slow down the parser, because
      it has to wade through more layers of procedure calls. That's one
      reason why Pascal compilers tend to compile faster than C
      compilers. If it's raw speed you want, stick with the Pascal
      syntax.
    </para>
  </sect1>
  <sect1 xmlns:id="the-parser">
    <title>The Parser</title>
    <para>
      Now that we've gotten through the decision-making process, we can
      press on with development of a parser. You've done this with me
      several times now, so you know the drill: we begin with a fresh
      copy of the cradle, and begin adding procedures one by one. So
      let's do it.
    </para>
    <para>
      We begin, as we did in the arithmetic case, by dealing only with
      Boolean literals rather than variables. This gives us a new kind
      of input token, so we're also going to need a new recognizer, and
      a new procedure to read instances of that token type. Let's start
      by defining the two new procedures:
    </para>
    <programlisting>
{--------------------------------------------------------------}
{ Recognize a Boolean Literal }

function IsBoolean(c: char): Boolean;
begin
   IsBoolean := UpCase(c) in ['T', 'F'];
end;


{--------------------------------------------------------------}
{ Get a Boolean Literal }

function GetBoolean: Boolean;
var c: char;
begin
   if not IsBoolean(Look) then Expected('Boolean Literal');
   GetBoolean := UpCase(Look) = 'T';
   GetChar;
end;
{--------------------------------------------------------------}
</programlisting>
    <para>
      Type these routines into your program. You can test them by adding
      into the main program the print statement
    </para>
    <programlisting>
WriteLn(GetBoolean);
</programlisting>
    <para>
      OK, compile the program and test it. As usual, it's not very
      impressive so far, but it soon will be.
    </para>
    <para>
      Now, when we were dealing with numeric data we had to arrange to
      generate code to load the values into <literal>D0</literal>. We
      need to do the same for Boolean data. The usual way to encode
      Boolean variables is to let 0 stand for <literal>FALSE</literal>,
      and some other value for <literal>TRUE</literal>. Many languages,
      such as C, use an integer 1 to represent it. But I prefer FFFF hex
      (or -1), because a bitwise <literal>NOT</literal> also becomes a
      Boolean <literal>NOT</literal>. So now we need to emit the right
      assembler code to load those values. The first cut at the Boolean
      expression parser (BoolExpression, of course) is:
    </para>
    <programlisting>
{---------------------------------------------------------------}
{ Parse and Translate a Boolean Expression }

procedure BoolExpression;
begin
   if not IsBoolean(Look) then Expected('Boolean Literal');
   if GetBoolean then
      EmitLn('MOVE #-1,D0')
   else
      EmitLn('CLR D0');
end;
{---------------------------------------------------------------}
</programlisting>
    <para>
      Add this procedure to your parser, and call it from the main
      program (replacing the print statement you had just put there). As
      you can see, we still don't have much of a parser, but the output
      code is starting to look more realistic.
    </para>
    <para>
      Next, of course, we have to expand the definition of a Boolean
      expression. We already have the BNF rule:
    </para>
    <programlisting>
 &lt;b-expression&gt; ::= &lt;b-term&gt; [&lt;orop&gt; &lt;b-term&gt;]*
</programlisting>
    <para>
      I prefer the Pascal versions of the &quot;orops&quot;,
      <literal>OR</literal> and <literal>XOR</literal>. But since we are
      keeping to single-character tokens here, I'll encode those with
      <literal>'|'</literal> and <literal>'~'</literal>. The next
      version of BoolExpression is almost a direct copy of the
      arithmetic procedure Expression:
    </para>
    <programlisting>
{--------------------------------------------------------------}
{ Recognize and Translate a Boolean OR }

procedure BoolOr;
begin
   Match('|');
   BoolTerm;
   EmitLn('OR (SP)+,D0');
end;




{--------------------------------------------------------------}
{ Recognize and Translate an Exclusive Or }

procedure BoolXor;
begin
   Match('~');
   BoolTerm;
   EmitLn('EOR (SP)+,D0');
end;


{---------------------------------------------------------------}
{ Parse and Translate a Boolean Expression }

procedure BoolExpression;
begin
   BoolTerm;
   while IsOrOp(Look) do begin
      EmitLn('MOVE D0,-(SP)');
      case Look of
       '|': BoolOr;
       '~': BoolXor;
      end;
   end;
end;
{---------------------------------------------------------------}
</programlisting>
    <para>
      Note the new recognizer <literal>IsOrOp</literal>, which is also a
      copy, this time of <literal>IsAddOp</literal>:
    </para>
    <programlisting>
{--------------------------------------------------------------}
{ Recognize a Boolean Orop }

function IsOrop(c: char): Boolean;
begin
   IsOrop := c in ['|', '~'];
end;
{--------------------------------------------------------------}
</programlisting>
    <para>
      OK, rename the old version of <literal>BoolExpression</literal> to
      <literal>BoolTerm</literal>, then enter the code above. Compile
      and test this version. At this point, the output code is starting
      to look pretty good. Of course, it doesn't make much sense to do a
      lot of Boolean algebra on constant values, but we'll soon be
      expanding the types of Booleans we deal with.
    </para>
    <para>
      You've probably already guessed what the next step is: The Boolean
      version of Term.
    </para>
    <para>
      Rename the current procedure <literal>BoolTerm</literal> to
      <literal>NotFactor</literal>, and enter the following new version
      of <literal>BoolTerm</literal>. Note that is is much simpler than
      the numeric version, since there is no equivalent of division.
    </para>
    <programlisting>
{---------------------------------------------------------------}
{ Parse and Translate a Boolean Term }

procedure BoolTerm;
begin
   NotFactor;
   while Look = '&amp;' do begin
      EmitLn('MOVE D0,-(SP)');
      Match('&amp;');
      NotFactor;
      EmitLn('AND (SP)+,D0');
   end;
end;
{--------------------------------------------------------------}
</programlisting>
    <para>
      Now, we're almost home. We are translating complex Boolean
      expressions, although only for constant values. The next step is
      to allow for the <literal>NOT</literal>. Write the following
      procedure:
    </para>
    <programlisting>
{--------------------------------------------------------------}
{ Parse and Translate a Boolean Factor with NOT }

procedure NotFactor;
begin
   if Look = '!' then begin
      Match('!');
      BoolFactor;
      EmitLn('EOR #-1,D0');
      end
   else
      BoolFactor;
end;
{--------------------------------------------------------------}
</programlisting>
    <para>
      And rename the earlier procedure to <literal>BoolFactor</literal>.
      Now try that. At this point the parser should be able to handle
      any Boolean expression you care to throw at it. Does it? Does it
      trap badly formed expressions?
    </para>
    <para>
      If you've been following what we did in the parser for math
      expressions, you know that what we did next was to expand the
      definition of a factor to include variables and parens. We don't
      have to do that for the Boolean factor, because those little items
      get taken care of by the next step. It takes just a one line
      addition to <literal>BoolFactor</literal> to take care of
      relations:
    </para>
    <programlisting>
{--------------------------------------------------------------}
{ Parse and Translate a Boolean Factor }

procedure BoolFactor;
begin
   if IsBoolean(Look) then
      if GetBoolean then
         EmitLn('MOVE #-1,D0')
      else
         EmitLn('CLR D0')
      else Relation;
end;
{--------------------------------------------------------------}
</programlisting>
    <para>
      You might be wondering when I'm going to provide for Boolean
      variables and parenthesized Boolean expressions. The answer is,
      I'm <emphasis>not</emphasis>! Remember, we took those out of the
      grammar earlier. Right now all I'm doing is encoding the grammar
      we've already agreed upon. The compiler itself can't tell the
      difference between a Boolean variable or expression and an
      arithmetic one ... all of those will be handled by
      <literal>Relation</literal>, either way.
    </para>
    <para>
      Of course, it would help to have some code for
      <literal>Relation</literal>. I don't feel comfortable, though,
      adding any more code without first checking out what we already
      have. So for now let's just write a dummy version of
      <literal>Relation</literal> that does nothing except eat the
      current character, and write a little message:
    </para>
    <programlisting>
{---------------------------------------------------------------}
{ Parse and Translate a Relation }

procedure Relation;
begin
   WriteLn('&lt;Relation&gt;');
   GetChar;
end;
{--------------------------------------------------------------}
</programlisting>
    <para>
      OK, key in this code and give it a try. All the old things should
      still work… you should be able to generate the code for
      <literal>AND</literal>s, <literal>OR</literal>s, and
      <literal>NOT</literal>s. In addition, if you type any alphabetic
      character you should get a little
      <literal>&lt;Relation&gt;</literal> place-holder, where a Boolean
      factor should be. Did you get that? Fine, then let's move on to
      the full-blown version of <literal>Relation</literal>.
    </para>
    <para>
      To get that, though, there is a bit of groundwork that we must lay
      first. Recall that a relation has the form
    </para>
    <programlisting>
 &lt;relation&gt;     ::= | &lt;expression&gt; [&lt;relop&gt; &lt;expression]
</programlisting>
    <para>
      Since we have a new kind of operator, we're also going to need a
      new Boolean function to recognize it. That function is shown
      below. Because of the single-character limitation, I'm sticking to
      the four operators that can be encoded with such a character (the
      &quot;not equals&quot; is encoded by <literal>'#'</literal>).
    </para>
    <programlisting>
{--------------------------------------------------------------}
{ Recognize a Relop }

function IsRelop(c: char): Boolean;
begin
   IsRelop := c in ['=', '#', '&lt;', '&gt;'];
end;
{--------------------------------------------------------------}
</programlisting>
    <para>
      Now, recall that we're using a zero or a -1 in register
      <literal>D0</literal> to represent a Boolean value, and also that
      the loop constructs expect the flags to be set to correspond. In
      implementing all this on the 68000, things get a a little bit
      tricky.
    </para>
    <para>
      Since the loop constructs operate only on the flags, it would be
      nice (and also quite efficient) just to set up those flags, and
      not load anything into <literal>D0</literal> at all. This would be
      fine for the loops and branches, but remember that the relation
      can be used <emphasis>anywhere</emphasis> a Boolean factor could
      be used. We may be storing its result to a Boolean variable. Since
      we can't know at this point how the result is going to be used, we
      must allow for <emphasis>both</emphasis> cases.
    </para>
    <para>
      Comparing numeric data is easy enough … the 68000 has an operation
      for that… but it sets the flags, not a value. What's more, the
      flags will always be set the same (zero if equal, etc.), while we
      need the zero flag set differently for the each of the different
      relops.
    </para>
    <para>
      The solution is found in the 68000 instruction
      <literal>Scc</literal>, which sets a byte value to 0000 or FFFF
      (funny how that works!) depending upon the result of the specified
      condition. If we make the destination byte to be
      <literal>D0</literal>, we get the Boolean value needed.
    </para>
    <para>
      Unfortunately, there's one final complication: unlike almost every
      other instruction in the 68000 set, <literal>Scc</literal> does
      <emphasis>not</emphasis> reset the condition flags to match the
      data being stored. So we have to do one last step, which is to
      test <literal>D0</literal> and set the flags to match it. It must
      seem to be a trip around the moon to get what we want: we first
      perform the test, then test the flags to set data into
      <literal>D0</literal>, then test <literal>D0</literal> to set the
      flags again. It is sort of roundabout, but it's the most
      straightforward way to get the flags right, and after all it's
      only a couple of instructions.
    </para>
    <para>
      I might mention here that this area is, in my opinion, the one
      that represents the biggest difference between the efficiency of
      hand-coded assembler language and compiler-generated code. We have
      seen already that we lose efficiency in arithmetic operations,
      although later I plan to show you how to improve that a bit. We've
      also seen that the control constructs themselves can be done quite
      efficiently … it's usually very difficult to improve on the code
      generated for an <literal>IF</literal> or a
      <literal>WHILE</literal>. But virtually every compiler I've ever
      seen generates terrible code, compared to assembler, for the
      computation of a Boolean function, and particularly for relations.
      The reason is just what I've hinted at above. When I'm writing
      code in assembler, I go ahead and perform the test the most
      convenient way I can, and then set up the branch so that it goes
      the way it should. In effect, I &quot;tailor&quot; every branch to
      the situation. The compiler can't do that (practically), and it
      also can't know that we don't want to store the result of the test
      as a Boolean variable. So it must generate the code in a very
      strict order, and it often ends up loading the result as a Boolean
      that never gets used for anything.
    </para>
    <para>
      In any case, we're now ready to look at the code for
      <literal>Relation</literal>. It's shown below with its companion
      procedures:
    </para>
    <programlisting>
{---------------------------------------------------------------}
{ Recognize and Translate a Relational &quot;Equals&quot; }

procedure Equals;
begin
   Match('=');
   Expression;
   EmitLn('CMP (SP)+,D0');
   EmitLn('SEQ D0');
end;




{---------------------------------------------------------------}
{ Recognize and Translate a Relational &quot;Not Equals&quot; }

procedure NotEquals;
begin
   Match('#');
   Expression;
   EmitLn('CMP (SP)+,D0');
   EmitLn('SNE D0');
end;


{---------------------------------------------------------------}
{ Recognize and Translate a Relational &quot;Less Than&quot; }

procedure Less;
begin
   Match('&lt;');
   Expression;
   EmitLn('CMP (SP)+,D0');
   EmitLn('SGE D0');
end;


{---------------------------------------------------------------}
{ Recognize and Translate a Relational &quot;Greater Than&quot; }

procedure Greater;
begin
   Match('&gt;');
   Expression;
   EmitLn('CMP (SP)+,D0');
   EmitLn('SLE D0');
end;


{---------------------------------------------------------------}
{ Parse and Translate a Relation }

procedure Relation;
begin
   Expression;
   if IsRelop(Look) then begin
      EmitLn('MOVE D0,-(SP)');
      case Look of
       '=': Equals;
       '#': NotEquals;
       '&lt;': Less;
       '&gt;': Greater;
      end;
   EmitLn('TST D0');
   end;
end;
{---------------------------------------------------------------}
</programlisting>
    <para>
      Now, that call to <literal>Expression</literal> looks familiar!
      Here is where the editor of your system comes in handy. We have
      already generated code for <literal>Expression</literal> and its
      buddies in previous sessions. You can copy them into your file
      now. Remember to use the single- character versions. Just to be
      certain, I've duplicated the arithmetic procedures below. If
      you're observant, you'll also see that I've changed them a little
      to make them correspond to the latest version of the syntax. This
      change is <emphasis>not</emphasis> necessary, so you may prefer to
      hold off on that until you're sure everything is working.
    </para>
    <programlisting>
{---------------------------------------------------------------}
{ Parse and Translate an Identifier }

procedure Ident;
var Name: char;
begin
   Name:= GetName;
   if Look = '(' then begin
      Match('(');
      Match(')');
      EmitLn('BSR ' + Name);
      end
   else
      EmitLn('MOVE ' + Name + '(PC),D0');
end;


{---------------------------------------------------------------}
{ Parse and Translate a Math Factor }

procedure Expression; Forward;

procedure Factor;
begin
   if Look = '(' then begin
      Match('(');
      Expression;
      Match(')');
      end
   else if IsAlpha(Look) then
      Ident
   else
      EmitLn('MOVE #' + GetNum + ',D0');
end;


{---------------------------------------------------------------}
{ Parse and Translate the First Math Factor }


procedure SignedFactor;
begin
   if Look = '+' then
      GetChar;
   if Look = '-' then begin
      GetChar;
      if IsDigit(Look) then
         EmitLn('MOVE #-' + GetNum + ',D0')
      else begin
         Factor;
         EmitLn('NEG D0');
      end;
   end
   else Factor;
end;




{--------------------------------------------------------------}
{ Recognize and Translate a Multiply }

procedure Multiply;
begin
   Match('*');
   Factor;
   EmitLn('MULS (SP)+,D0');
end;


{-------------------------------------------------------------}
{ Recognize and Translate a Divide }

procedure Divide;
begin
   Match('/');
   Factor;
   EmitLn('MOVE (SP)+,D1');
   EmitLn('EXS.L D0');
   EmitLn('DIVS D1,D0');
end;


{---------------------------------------------------------------}
{ Parse and Translate a Math Term }

procedure Term;
begin
   SignedFactor;
   while Look in ['*', '/'] do begin
      EmitLn('MOVE D0,-(SP)');
      case Look of
       '*': Multiply;
       '/': Divide;
      end;
   end;
end;


{---------------------------------------------------------------}
{ Recognize and Translate an Add }

procedure Add;
begin
   Match('+');
   Term;
   EmitLn('ADD (SP)+,D0');
end;


{---------------------------------------------------------------}
{ Recognize and Translate a Subtract }

procedure Subtract;
begin
   Match('-');
   Term;
   EmitLn('SUB (SP)+,D0');
   EmitLn('NEG D0');
end;




{---------------------------------------------------------------}
{ Parse and Translate an Expression }

procedure Expression;
begin
   Term;
   while IsAddop(Look) do begin
      EmitLn('MOVE D0,-(SP)');
      case Look of
       '+': Add;
       '-': Subtract;
      end;
   end;
end;
{---------------------------------------------------------------}
</programlisting>
    <para>
      There you have it… a parser that can handle both arithmetic AND
      Boolean algebra, and things that combine the two through the use
      of relops. I suggest you file away a copy of this parser in a safe
      place for future reference, because in our next step we're going
      to be chopping it up.
    </para>
  </sect1>
  <sect1 xmlns:id="merging-with-control-constructs">
    <title>Merging with Control Constructs</title>
    <para>
      At this point, let's go back to the file we had previously built
      that parses control constructs. Remember those little dummy
      procedures called <literal>Condition</literal> and
      <literal>Expression</literal>? Now you know what goes in their
      places!
    </para>
    <para>
      I warn you, you're going to have to do some creative editing here,
      so take your time and get it right. What you need to do is to copy
      all of the procedures from the logic parser, from
      <literal>Ident</literal> through
      <literal>BoolExpression</literal>, into the parser for control
      constructs. Insert them at the current location of
      <literal>Condition</literal>. Then delete that procedure, as well
      as the dummy <literal>Expression</literal>. Next, change every
      call to <literal>Condition</literal> to refer to
      <literal>BoolExpression</literal> instead. Finally, copy the
      procedures <literal>IsMulop</literal>, <literal>IsOrOp</literal>,
      <literal>IsRelop</literal>, <literal>IsBoolean</literal>, and
      <literal>GetBoolean</literal> into place. That should do it.
    </para>
    <para>
      Compile the resulting program and give it a try. Since we haven't
      used this program in awhile, don't forget that we used
      single-character tokens for <literal>IF</literal>,
      <literal>WHILE</literal>, etc. Also don't forget that any letter
      not a keyword just gets echoed as a block.
    </para>
    <para>
      Try
    </para>
    <programlisting>
 ia=bxlye
</programlisting>
    <para>
      which stands for
      <literal>&quot;IF a=b X ELSE Y ENDIF&quot;</literal>.
    </para>
    <para>
      What do you think? Did it work? Try some others.
    </para>
  </sect1>
  <sect1 xmlns:id="adding-assignments">
    <title>Adding Assignments</title>
    <para>
      As long as we're this far, and we already have the routines for
      expressions in place, we might as well replace the
      &quot;blocks&quot; with real assignment statements. We've already
      done that before, so it won't be too hard. Before taking that
      step, though, we need to fix something else.
    </para>
    <para>
      We're soon going to find that the one-line &quot;programs&quot;
      that we're having to write here will really cramp our style. At
      the moment we have no cure for that, because our parser doesn't
      recognize the end-of-line characters, the carriage return (CR) and
      the line feed (LF). So before going any further let's plug that
      hole.
    </para>
    <para>
      There are a couple of ways to deal with the CR/LFs. One (the
      C/Unix approach) is just to treat them as additional white space
      characters and ignore them. That's actually not such a bad
      approach, but it does sort of produce funny results for our parser
      as it stands now. If it were reading its input from a source file
      as any self-respecting <emphasis>real</emphasis> compiler does,
      there would be no problem. But we're reading input from the
      keyboard, and we're sort of conditioned to expect something to
      happen when we hit the return key. It won't, if we just skip over
      the CR and LF (try it). So I'm going to use a different method
      here, which is <emphasis>not</emphasis> necessarily the best
      approach in the long run. Consider it a temporary kludge until
      we're further along.
    </para>
    <para>
      Instead of skipping the CR/LF, We'll let the parser go ahead and
      catch them, then introduce a special procedure, analogous to
      <literal>SkipWhite</literal>, that skips them only in specified
      &quot;legal&quot; spots.
    </para>
    <para>
      Here's the procedure:
    </para>
    <programlisting>
{--------------------------------------------------------------}
{ Skip a CRLF }

procedure Fin;
begin
   if Look = CR then GetChar;
   if Look = LF then GetChar;
end;

{--------------------------------------------------------------}
</programlisting>
    <para>
      Now, add two calls to <literal>Fin</literal> in procedure
      <literal>Block</literal>, like this:
    </para>
    <programlisting>
{--------------------------------------------------------------}
{ Recognize and Translate a Statement Block }

procedure Block(L: string);
begin
   while not(Look in ['e', 'l', 'u']) do begin
      Fin;
      case Look of
       'i': DoIf(L);
       'w': DoWhile;
       'p': DoLoop;
       'r': DoRepeat;
       'f': DoFor;
       'd': DoDo;
       'b': DoBreak(L);
       else Other;
      end;
      Fin;
 end;
end;
{--------------------------------------------------------------}
</programlisting>
    <para>
      Now, you'll find that you can use multiple-line
      &quot;programs.&quot; The only restriction is that you can't
      separate an <literal>IF</literal> or <literal>WHILE</literal>
      token from its predicate.
    </para>
    <para>
      Now we're ready to include the assignment statements. Simply
      change that call to <literal>Other</literal> in procedure
      <literal>Block</literal> to a call to
      <literal>Assignment</literal>, and add the following procedure,
      copied from one of our earlier programs. Note that
      <literal>Assignment</literal> now calls
      <literal>BoolExpression</literal>, so that we can assign Boolean
      variables.
    </para>
    <programlisting>
{--------------------------------------------------------------}
{ Parse and Translate an Assignment Statement }

procedure Assignment;
var Name: char;
begin
   Name := GetName;
   Match('=');
   BoolExpression;
   EmitLn('LEA ' + Name + '(PC),A0');
   EmitLn('MOVE D0,(A0)');
end;
{--------------------------------------------------------------}
</programlisting>
    <para>
      With that change, you should now be able to write reasonably
      realistic-looking programs, subject only to our limitation on
      single-character tokens. My original intention was to get rid of
      that limitation for you, too. However, that's going to require a
      fairly major change to what we've done so far. We need a true
      lexical scanner, and that requires some structural changes. They
      are not <emphasis>big</emphasis> changes that require us to throw
      away all of what we've done so far… with care, it can be done with
      very minimal changes, in fact. But it does require that care.
    </para>
    <para>
      This installment has already gotten pretty long, and it contains
      some pretty heavy stuff, so I've decided to leave that step until
      next time, when you've had a little more time to digest what we've
      done and are ready to start fresh.
    </para>
    <para>
      In the next installment, then, we'll build a lexical scanner and
      eliminate the single-character barrier once and for all. We'll
      also write our first complete compiler, based on what we've done
      in this session. See you then.
    </para>
  </sect1>
</chapter>
